{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"PartyService \u00b6 PartyService is a stand-alone module which handles all your matchmaking and many other things. Its main features are: Feature-rich party system Global matchmaking queues including: Priorities handles all your MessagingService calls handles all your teleportation PartyService lets you write your own interface and doesn't impose any annoying features. It has a clear and smart API. This module is built for large games with many players and keeps MemoryStoreService requests to a minimum. Features coming soon: Matching based on skill and other heavy improvements Tracking of available requests, deal more thriftily with requests when close to limit With PartyService's available tools it would be easy to make things like global lobbies/rooms and server lists Self-adapting polling cooldown This module is still in beta and therefore has bugs. MemoryStoreService has bugs as well.","title":"Introduction"},{"location":"#partyservice","text":"PartyService is a stand-alone module which handles all your matchmaking and many other things. Its main features are: Feature-rich party system Global matchmaking queues including: Priorities handles all your MessagingService calls handles all your teleportation PartyService lets you write your own interface and doesn't impose any annoying features. It has a clear and smart API. This module is built for large games with many players and keeps MemoryStoreService requests to a minimum. Features coming soon: Matching based on skill and other heavy improvements Tracking of available requests, deal more thriftily with requests when close to limit With PartyService's available tools it would be easy to make things like global lobbies/rooms and server lists Self-adapting polling cooldown This module is still in beta and therefore has bugs. MemoryStoreService has bugs as well.","title":"PartyService"},{"location":"about/","text":"This section contains general information about PartyService. Matching is not 100% done and will be heavily improved in the future. All party members are in the same server, parties don't exist in multiple servers. Parties always have a leader. If the leader gets removed, a random player will become leader. AddAsync and RemoveAsync are built for multiple players. It is possible to use a single player, but try to use multiple in order to save requests. Network calls are automatically retried, so you don't have to use pcall unless you want to add additional error handling. One player in the queue takes up 10 + Length of UserId bytes, a group takes up 11 + Length of the UserIds + Amount of players . Information on PartyService limits: Priorities range from 1 to 99 9999 entities per priority (so theoretically 989,901 entities per queue) Information on MSS limits : For each player in the game, you get 100 AvailableRequests per minute (capped at 1000 players/100,000 requests) While your SpentRequests in the last 60 seconds + your AvailableRequests are lower than the limit, it will regenerate math.ceil(limit / 60) requests per second","title":"About"},{"location":"api/","text":"General notices: Functions with Async in their name will yield. The lowercase player type is equal to Player | int64 . This means it can be a player instance or its UserId. {Value} stands for {[number]:Value} , so an array that contains one or multiple of Value . Parameters marked with ? are optional. PartyService \u00b6 Properties \u00b6 Parties \u00b6 {[ PartyId ]: Party } Parties A container of all the parties existing in the server. Queues \u00b6 {[ Name ]: Queue } Queues A container of all the queues created on the server. Settings \u00b6 Settings that determine how PartyService operates. DefaultRank \u00b6 string DefaultRank The default rank of parties that players get added to when not specifying a rank. RanksAddedByDefault \u00b6 { string } RanksAddedByDefault Ranks that will be added by default when creating parties. TeleportDataValidTime \u00b6 number TeleportDataValidTime Determines how long the TeleportData is valid. PlayerLostTime \u00b6 number PlayerLostTime After this time, players will be considered lost in the teleport process and removed from the party. This time starts when the first player of a party arrives in the game. PollingCooldown \u00b6 number PollingCooldown How often PartyService will make a request to the queues in order to check if there are matches. If this is nil , it will be automatically updated in the future according to MemoryStoreService limits. SplitUpGroups \u00b6 boolean SplitUpGroups Groups in the queue will always stay in the same match. However they could be split up into different teams if they don't fit. QueueExpiration \u00b6 int64 QueueExpiration When there haven't been any changes to the queue after this time, it will be cleared. Messaging \u00b6 A module which handles all your MessagingService calls. It includes features like packet switching which allows you to send messages with unlimited size. This module is supposed to become even smarter in the future. SubscribeAsync \u00b6 void SubscribeAsync ( string topic , function callback ( any message , number sent ) -> ()) Begin listening to the given topic. The callback is invoked with received messages and the time when the message was sent. Unsubscribe \u00b6 void Unsubscribe ( string topic ) Stop listening to the given topic. Publish \u00b6 void Publish ( string topic , any message ) Sends the provided message to all subscribers to the topic. Events \u00b6 PlayerLoaded \u00b6 RBXScriptSignal PlayerLoaded ( Player player , any teleportData ) Fires when a player was loaded after entering the server. This event is guaranteed to fire, so you can use it instead of PlayerAdded in order to prevent errors when doing party-related actions with the player. PartyAdded \u00b6 RBXScriptSignal PartyAdded ( Party party ) Fires when a party was created. PartyRemoving \u00b6 RBXScriptSignal PartyRemoving ( Party party ) Fires right before a party gets destroyed. Methods \u00b6 CreateParty \u00b6 Party CreateParty ( player leader , { player } | {[ Rank ]:{ player }} members ? ) Creates a new party object. IsInParty \u00b6 boolean , Party ? IsInParty ( player player , Party party ? ) Checks if the given player is in a party, if the 2nd argument is provided it only checks that party. GetPartyFromPlayer \u00b6 Party , Rank GetPartyFromPlayer ( player player ) Returns the party and rank of the given player. GetQueue \u00b6 Queue GetQueue ( config ) Creates a new queue object or returns an existing one with the provided name. config contains the following: { string Name , int TeamAmount ? , int TeamSize , function MatchCallback ({ Player } players , any teams ) -> (), function GetPriority ( Player player ) -> ( number ? ) ? } The MatchCallback function gets invoked with an array of the players that are in this server and a table with the team composition. It could look like this: { { 2376312 , 1238712 , 2318918 , 9852347 }, <- team of four players { 1293812 , 21748923 , 1263712 , 9812371 } } Classic example: local queue = PartyService : GetQueue ({ Name = \"Main\" , TeamAmount = 2 , TeamSize = 4 , MatchCallback = function ( players , teams ) local teleportOptions = Instance . new ( \"TeleportOptions\" ) teleportOptions . ShouldReserveServer = true teleportOptions : SetTeleportData ({ Teams = teams }) local result = PartyService : TeleportAsync ( 6853732367 , players , teleportOptions ) print ( \"Teleporting\" , players , \"to reserved server with Id\" , result . PrivateServerId ) end , GetPriority = function ( player ) return player : GetAttribute ( \"Priority\" ) end }) IsInQueueAsync \u00b6 boolean , string ? IsInQueueAsync ( player player , string queueName ? ) Checks if the given player is in a queue, if the 2nd argument is provided it checks only that queue. TeleportAsync \u00b6 TeleportAsyncResult TeleportAsync ( int64 placeId , Player | Party | { Player | Party } players , TeleportOptions teleportOptions ? ) This is a wrapper around TeleportService:TeleportAsync which manages TeleportData. It ensures that parties persist after teleports. Please pass parties and not the players of the party in order to make it to work. This also sets Party.Teleporting to true . If you send TeleportData, it must be a table without any number keys. Party \u00b6 Properties \u00b6 ClassName \u00b6 string ClassName A string representing what class this object belongs to. Created \u00b6 int Created Unix time in seconds at which the party was created. Leader \u00b6 int64 Leader A property representing the party leader's UserId. Members \u00b6 { int64 } Members An array of the party members. If added in PartyService.Settings.RanksAddedByDefault , more ranks like this will exist in the party. PartyId \u00b6 int PartyId This is a randomly generated 8 digit Id. It is not guaranteed that it is unique, however the chance is 0.0000000111% to get a duplicate. Methods \u00b6 AddPlayer \u00b6 void AddPlayer ( player player , string rank ? ) Adds a player to the party, if given to the specified rank. RemovePlayer \u00b6 void RemovePlayer ( player player ) Removes the player from the party. AddRank \u00b6 void AddRank ( string rankName , { player } players ? ) You can add a rank yourself by doing Party.Rank = {} . This function should rather be used when you want to add players to it at the same time. RemoveRank \u00b6 void RemoveRank ( string rankName ) Removes a rank. Members of the rank will be added to PartyService.Settings.DefaultRank . ChangePlayerRank \u00b6 void ChangePlayerRank ( player player , string newRank ) Change the player's rank in the party. GetPlayers \u00b6 { player } GetPlayers ( string returnType ? ) Get all players in the party. At the moment, the only option for returnType is \"UserId\" . By default, it will return player instances. GetPlayersWithRank \u00b6 { Player } GetPlayersWithRank ( string rank ) Returns all players with the given rank. If you want UserIds, you can just index the party with the rank. GetRankOfPlayer \u00b6 string GetRankOfPlayer ( player player ) Returns the rank of the player. Destroy \u00b6 void Destroy () This is the correct way to dispose of parties. Queue \u00b6 The queue in Roblox's backend is designed like this: The first two numbers of the key are the priority, the other 4 are the number of entity in this priority [\"010001\"] = 37292193 ^ ^ number of entity in the priority priority (this isn't the same priority you provide) { [\"550001\"] = 24762332 [\"550002\"] = 1387132614 [\"990001\"] = {321761, 213871, 213817127} <- group of 3 players [\"990002\"] = 935144631 <- this would be the 2nd entity in the priority and 6th player in the queue [\"990003\"] = 12376612 } [\"410784\"] = 59826321 -> priority 41, entity number 784 in priority, player with UserId 59826321 I will probably create a framework for MSS (like PartyService.Messaging) which will be used internally, but is also available to the user. Many more features are planned for queues. You could for example consider regions and friends. Properties \u00b6 ClassName \u00b6 string ClassName A string representing what class this object belongs to. Config \u00b6 {[ string ]: any } Config The settings object you passed at PartyService:GetQueue . Events \u00b6 PlayerAdded \u00b6 RBXScriptSignal PlayerAdded ({ Player } players ) Fires when players in this server have been added to the queue. PlayerRemoved \u00b6 RBXScriptSignal PlayerRemoved ({ Player } players ) Fires when players in this server have been removed from the queue. Methods \u00b6 AddAsync \u00b6 void AddAsync ( Player | { Player | { Player }} players ) Add players to the queue. players can be a single player or an array containing players and groups. RemoveAsync \u00b6 void RemoveAsync ( player | { player } players ) Remove players from the queue. Destroy \u00b6 void Destroy ( boolean wipeQueue ? ) This is the correct way to dispose of queues. Passing true will yield the function and clear the queue in Roblox's backend.","title":"API"},{"location":"api/#partyservice","text":"","title":"PartyService"},{"location":"api/#properties","text":"","title":"Properties"},{"location":"api/#parties","text":"{[ PartyId ]: Party } Parties A container of all the parties existing in the server.","title":"Parties"},{"location":"api/#queues","text":"{[ Name ]: Queue } Queues A container of all the queues created on the server.","title":"Queues"},{"location":"api/#settings","text":"Settings that determine how PartyService operates.","title":"Settings"},{"location":"api/#defaultrank","text":"string DefaultRank The default rank of parties that players get added to when not specifying a rank.","title":"DefaultRank"},{"location":"api/#ranksaddedbydefault","text":"{ string } RanksAddedByDefault Ranks that will be added by default when creating parties.","title":"RanksAddedByDefault"},{"location":"api/#teleportdatavalidtime","text":"number TeleportDataValidTime Determines how long the TeleportData is valid.","title":"TeleportDataValidTime"},{"location":"api/#playerlosttime","text":"number PlayerLostTime After this time, players will be considered lost in the teleport process and removed from the party. This time starts when the first player of a party arrives in the game.","title":"PlayerLostTime"},{"location":"api/#pollingcooldown","text":"number PollingCooldown How often PartyService will make a request to the queues in order to check if there are matches. If this is nil , it will be automatically updated in the future according to MemoryStoreService limits.","title":"PollingCooldown"},{"location":"api/#splitupgroups","text":"boolean SplitUpGroups Groups in the queue will always stay in the same match. However they could be split up into different teams if they don't fit.","title":"SplitUpGroups"},{"location":"api/#queueexpiration","text":"int64 QueueExpiration When there haven't been any changes to the queue after this time, it will be cleared.","title":"QueueExpiration"},{"location":"api/#messaging","text":"A module which handles all your MessagingService calls. It includes features like packet switching which allows you to send messages with unlimited size. This module is supposed to become even smarter in the future.","title":"Messaging"},{"location":"api/#subscribeasync","text":"void SubscribeAsync ( string topic , function callback ( any message , number sent ) -> ()) Begin listening to the given topic. The callback is invoked with received messages and the time when the message was sent.","title":"SubscribeAsync"},{"location":"api/#unsubscribe","text":"void Unsubscribe ( string topic ) Stop listening to the given topic.","title":"Unsubscribe"},{"location":"api/#publish","text":"void Publish ( string topic , any message ) Sends the provided message to all subscribers to the topic.","title":"Publish"},{"location":"api/#events","text":"","title":"Events"},{"location":"api/#playerloaded","text":"RBXScriptSignal PlayerLoaded ( Player player , any teleportData ) Fires when a player was loaded after entering the server. This event is guaranteed to fire, so you can use it instead of PlayerAdded in order to prevent errors when doing party-related actions with the player.","title":"PlayerLoaded"},{"location":"api/#partyadded","text":"RBXScriptSignal PartyAdded ( Party party ) Fires when a party was created.","title":"PartyAdded"},{"location":"api/#partyremoving","text":"RBXScriptSignal PartyRemoving ( Party party ) Fires right before a party gets destroyed.","title":"PartyRemoving"},{"location":"api/#methods","text":"","title":"Methods"},{"location":"api/#createparty","text":"Party CreateParty ( player leader , { player } | {[ Rank ]:{ player }} members ? ) Creates a new party object.","title":"CreateParty"},{"location":"api/#isinparty","text":"boolean , Party ? IsInParty ( player player , Party party ? ) Checks if the given player is in a party, if the 2nd argument is provided it only checks that party.","title":"IsInParty"},{"location":"api/#getpartyfromplayer","text":"Party , Rank GetPartyFromPlayer ( player player ) Returns the party and rank of the given player.","title":"GetPartyFromPlayer"},{"location":"api/#getqueue","text":"Queue GetQueue ( config ) Creates a new queue object or returns an existing one with the provided name. config contains the following: { string Name , int TeamAmount ? , int TeamSize , function MatchCallback ({ Player } players , any teams ) -> (), function GetPriority ( Player player ) -> ( number ? ) ? } The MatchCallback function gets invoked with an array of the players that are in this server and a table with the team composition. It could look like this: { { 2376312 , 1238712 , 2318918 , 9852347 }, <- team of four players { 1293812 , 21748923 , 1263712 , 9812371 } } Classic example: local queue = PartyService : GetQueue ({ Name = \"Main\" , TeamAmount = 2 , TeamSize = 4 , MatchCallback = function ( players , teams ) local teleportOptions = Instance . new ( \"TeleportOptions\" ) teleportOptions . ShouldReserveServer = true teleportOptions : SetTeleportData ({ Teams = teams }) local result = PartyService : TeleportAsync ( 6853732367 , players , teleportOptions ) print ( \"Teleporting\" , players , \"to reserved server with Id\" , result . PrivateServerId ) end , GetPriority = function ( player ) return player : GetAttribute ( \"Priority\" ) end })","title":"GetQueue"},{"location":"api/#isinqueueasync","text":"boolean , string ? IsInQueueAsync ( player player , string queueName ? ) Checks if the given player is in a queue, if the 2nd argument is provided it checks only that queue.","title":"IsInQueueAsync"},{"location":"api/#teleportasync","text":"TeleportAsyncResult TeleportAsync ( int64 placeId , Player | Party | { Player | Party } players , TeleportOptions teleportOptions ? ) This is a wrapper around TeleportService:TeleportAsync which manages TeleportData. It ensures that parties persist after teleports. Please pass parties and not the players of the party in order to make it to work. This also sets Party.Teleporting to true . If you send TeleportData, it must be a table without any number keys.","title":"TeleportAsync"},{"location":"api/#party","text":"","title":"Party"},{"location":"api/#properties_1","text":"","title":"Properties"},{"location":"api/#classname","text":"string ClassName A string representing what class this object belongs to.","title":"ClassName"},{"location":"api/#created","text":"int Created Unix time in seconds at which the party was created.","title":"Created"},{"location":"api/#leader","text":"int64 Leader A property representing the party leader's UserId.","title":"Leader"},{"location":"api/#members","text":"{ int64 } Members An array of the party members. If added in PartyService.Settings.RanksAddedByDefault , more ranks like this will exist in the party.","title":"Members"},{"location":"api/#partyid","text":"int PartyId This is a randomly generated 8 digit Id. It is not guaranteed that it is unique, however the chance is 0.0000000111% to get a duplicate.","title":"PartyId"},{"location":"api/#methods_1","text":"","title":"Methods"},{"location":"api/#addplayer","text":"void AddPlayer ( player player , string rank ? ) Adds a player to the party, if given to the specified rank.","title":"AddPlayer"},{"location":"api/#removeplayer","text":"void RemovePlayer ( player player ) Removes the player from the party.","title":"RemovePlayer"},{"location":"api/#addrank","text":"void AddRank ( string rankName , { player } players ? ) You can add a rank yourself by doing Party.Rank = {} . This function should rather be used when you want to add players to it at the same time.","title":"AddRank"},{"location":"api/#removerank","text":"void RemoveRank ( string rankName ) Removes a rank. Members of the rank will be added to PartyService.Settings.DefaultRank .","title":"RemoveRank"},{"location":"api/#changeplayerrank","text":"void ChangePlayerRank ( player player , string newRank ) Change the player's rank in the party.","title":"ChangePlayerRank"},{"location":"api/#getplayers","text":"{ player } GetPlayers ( string returnType ? ) Get all players in the party. At the moment, the only option for returnType is \"UserId\" . By default, it will return player instances.","title":"GetPlayers"},{"location":"api/#getplayerswithrank","text":"{ Player } GetPlayersWithRank ( string rank ) Returns all players with the given rank. If you want UserIds, you can just index the party with the rank.","title":"GetPlayersWithRank"},{"location":"api/#getrankofplayer","text":"string GetRankOfPlayer ( player player ) Returns the rank of the player.","title":"GetRankOfPlayer"},{"location":"api/#destroy","text":"void Destroy () This is the correct way to dispose of parties.","title":"Destroy"},{"location":"api/#queue","text":"The queue in Roblox's backend is designed like this: The first two numbers of the key are the priority, the other 4 are the number of entity in this priority [\"010001\"] = 37292193 ^ ^ number of entity in the priority priority (this isn't the same priority you provide) { [\"550001\"] = 24762332 [\"550002\"] = 1387132614 [\"990001\"] = {321761, 213871, 213817127} <- group of 3 players [\"990002\"] = 935144631 <- this would be the 2nd entity in the priority and 6th player in the queue [\"990003\"] = 12376612 } [\"410784\"] = 59826321 -> priority 41, entity number 784 in priority, player with UserId 59826321 I will probably create a framework for MSS (like PartyService.Messaging) which will be used internally, but is also available to the user. Many more features are planned for queues. You could for example consider regions and friends.","title":"Queue"},{"location":"api/#properties_2","text":"","title":"Properties"},{"location":"api/#classname_1","text":"string ClassName A string representing what class this object belongs to.","title":"ClassName"},{"location":"api/#config","text":"{[ string ]: any } Config The settings object you passed at PartyService:GetQueue .","title":"Config"},{"location":"api/#events_1","text":"","title":"Events"},{"location":"api/#playeradded","text":"RBXScriptSignal PlayerAdded ({ Player } players ) Fires when players in this server have been added to the queue.","title":"PlayerAdded"},{"location":"api/#playerremoved","text":"RBXScriptSignal PlayerRemoved ({ Player } players ) Fires when players in this server have been removed from the queue.","title":"PlayerRemoved"},{"location":"api/#methods_2","text":"","title":"Methods"},{"location":"api/#addasync","text":"void AddAsync ( Player | { Player | { Player }} players ) Add players to the queue. players can be a single player or an array containing players and groups.","title":"AddAsync"},{"location":"api/#removeasync","text":"void RemoveAsync ( player | { player } players ) Remove players from the queue.","title":"RemoveAsync"},{"location":"api/#destroy_1","text":"void Destroy ( boolean wipeQueue ? ) This is the correct way to dispose of queues. Passing true will yield the function and clear the queue in Roblox's backend.","title":"Destroy"},{"location":"changelog/","text":"0.3.0-beta \u00b6 First release","title":"Changelog"},{"location":"changelog/#030-beta","text":"First release","title":"0.3.0-beta"},{"location":"tutorial/","text":"This section introduces basic functions of the module. Firstly, get the module here and insert it into your game (preferably ServerStorage). PartyService only works on the server. Create a script and require it: local PartyService = require ( game . ServerStorage . PartyService ) After that, we'll listen to players joining the game. PartyService.PlayerLoaded fires when a player was loaded after entering the server. PartyService . PlayerLoaded : Connect ( function ( player ) end ) If the player isn't in a party already, we will create one with them being the leader. PartyService . PlayerLoaded : Connect ( function ( player ) local party = PartyService : GetPartyFromPlayer ( player ) if not party then party = PartyService : CreateParty ( player ) end end ) Now let's create a matchmaking queue. This is a classic example: local queue = PartyService : GetQueue ({ Name = \"Main\" , TeamAmount = 2 , TeamSize = 4 , MatchCallback = function ( players , teams ) local teleportOptions = Instance . new ( \"TeleportOptions\" ) teleportOptions . ShouldReserveServer = true teleportOptions : SetTeleportData ({ Teams = teams }) local result = PartyService : TeleportAsync ( 6853732367 , players , teleportOptions ) print ( \"Teleporting\" , players , \"to reserved server with Id\" , result . PrivateServerId ) end , GetPriority = function ( player ) return player : GetAttribute ( \"Priority\" ) end }) Matches will have 2 teams consisting of 4 players each. When there's a match, the players will get teleported to a reserved server. After pasting the code before the PlayerLoaded event, we can now add the player to the queue. local queue = ... PartyService . PlayerLoaded : Connect ( function ( player ) queue : AddAsync ( player ) end ) PartyService.Messaging is a module which handles all your MessagingService calls. It includes features like packet switching which allows you to send messages with unlimited size. local messaging = PartyService . Messaging messaging : SubscribeAsync ( \"Test\" , function ( data , sent ) print ( data , sent ) end ) messaging : Publish ( \"Test\" , \"Test message\" ) messaging : Publish ( \"Test\" , string.rep ( \"a\" , 10238 )) --this is 10kB large task . wait ( 1 ) messaging : Unsubscribe ( \"Test\" ) Info Here is an example of what you could create with PartyService.","title":"Tutorial"}]}